"""Script generation engine using LLM.

This module provides LLM-powered script generation for sequencing QC tasks.
The LLM generates Python or bash scripts based on experiment understanding.
"""

from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field

from aco.engine.gemini import GeminiClient, get_gemini_client
from aco.engine.models import ExperimentUnderstanding


class ScriptType(str, Enum):
    """Types of scripts that can be generated."""
    
    PYTHON = "python"
    BASH = "bash"
    R = "r"


class ScriptCategory(str, Enum):
    """Categories of QC scripts."""
    
    PARSE_ASSAY = "parse_assay"  # Barcode validation, read structure
    SEQUENCING_HEALTH = "sequencing_health"  # Quality metrics, base diversity
    QC_METRICS = "qc_metrics"  # Knee plots, hashtag profiles
    DATA_EXTRACTION = "data_extraction"  # Extract statistics from files
    CUSTOM = "custom"


class GeneratedScript(BaseModel):
    """A script generated by the LLM."""
    
    name: str = Field(..., description="Script filename")
    category: ScriptCategory = Field(..., description="Script category")
    script_type: ScriptType = Field(..., description="Script language")
    description: str = Field(..., description="What the script does")
    code: str = Field(..., description="The script code")
    dependencies: list[str] = Field(
        default_factory=list, description="Required packages/tools"
    )
    input_files: list[str] = Field(
        default_factory=list, description="Expected input files"
    )
    output_files: list[str] = Field(
        default_factory=list, description="Files the script will create"
    )
    estimated_runtime: str | None = Field(
        default=None, description="Estimated runtime"
    )
    requires_approval: bool = Field(
        default=True, description="Whether user approval is needed before running"
    )


class ScriptPlan(BaseModel):
    """A plan for scripts to generate and execute."""
    
    manifest_id: str = Field(..., description="Associated manifest ID")
    scripts: list[GeneratedScript] = Field(
        default_factory=list, description="Scripts to generate"
    )
    execution_order: list[str] = Field(
        default_factory=list, description="Order to run scripts (by name)"
    )
    total_estimated_runtime: str | None = Field(
        default=None, description="Total estimated runtime"
    )
    generated_at: datetime = Field(default_factory=datetime.now)
    is_approved: bool = Field(default=False)


class ExecutionResult(BaseModel):
    """Result of script execution."""
    
    script_name: str = Field(..., description="Name of the script that was run")
    success: bool = Field(..., description="Whether execution succeeded")
    exit_code: int = Field(..., description="Process exit code")
    stdout: str = Field(default="", description="Standard output")
    stderr: str = Field(default="", description="Standard error")
    duration_seconds: float = Field(..., description="Execution time in seconds")
    started_at: datetime = Field(default_factory=datetime.now)
    completed_at: datetime | None = Field(default=None)
    error_message: str | None = Field(default=None, description="Error message if failed")
    output_files: list[str] = Field(
        default_factory=list, description="Files created by the script"
    )

    class Config:
        arbitrary_types_allowed = True


class ExecutionConfig(BaseModel):
    """Configuration for script execution."""
    
    timeout_seconds: int = Field(default=300, description="Max execution time")
    capture_output: bool = Field(default=True, description="Capture stdout/stderr")
    working_directory: str | None = Field(default=None, description="Working directory")
    environment: dict[str, str] = Field(
        default_factory=dict, description="Additional env vars"
    )
    python_executable: str = Field(
        default="python3", description="Python interpreter path"
    )


SCRIPT_GENERATION_SYSTEM = """You are an expert bioinformatics programmer specializing in sequencing QC pipelines.
Your role is to generate production-quality scripts that:
1. Are well-documented with clear comments
2. Handle errors gracefully
3. Produce structured output (JSON, CSV) for downstream processing
4. Are efficient and avoid unnecessary computation
5. Use standard bioinformatics libraries (pysam, scanpy, pandas, etc.)

When generating scripts:
- Always validate input files exist before processing
- Use logging for progress tracking
- Output results to specified output directory
- Include a main() function with proper argument parsing
- Generate scripts that can run independently
"""


SCRIPT_PLAN_PROMPT = """Based on the following experiment understanding, generate a plan for QC scripts.

# Experiment Understanding

{understanding_json}

# Available Files

{file_list}

# Instructions

Generate a list of scripts that will:
1. **Parse/Validate Assay**: If single-cell, validate barcode structure against whitelists
2. **Assess Sequencing Health**: Quality scores, base composition, mapping rates
3. **Generate QC Metrics**: Knee plots, UMI counts, gene detection rates

For each script, specify:
- Name, category, and script type (prefer Python)
- Clear description of purpose
- Required dependencies
- Input and output files
- Execution order

Focus on scripts that can actually be run with the available files.
Prioritize essential QC checks over nice-to-haves.
"""


SCRIPT_CODE_PROMPT = """Generate the complete code for the following script:

# Script Specification
Name: {script_name}
Category: {category}
Type: {script_type}
Description: {description}

# Experiment Context
{understanding_summary}

# Input Files
{input_files}

# Output Directory
{output_dir}

# Expected Outputs
{output_files}

# Dependencies Available
{dependencies}

# Instructions

Generate a complete, runnable script that:
1. Parses command-line arguments for input/output paths
2. Validates inputs exist
3. Performs the analysis described
4. Saves results to the output directory
5. Prints a summary to stdout
6. Returns exit code 0 on success, non-zero on failure

Include comprehensive error handling and logging.
The script should be self-contained and ready to run.
"""


async def generate_script_plan(
    understanding: ExperimentUnderstanding,
    file_list: list[str],
    client: GeminiClient | None = None,
) -> ScriptPlan:
    """Generate a plan for QC scripts based on experiment understanding.
    
    Args:
        understanding: The experiment understanding
        file_list: List of available file paths
        client: Optional Gemini client
    
    Returns:
        ScriptPlan with scripts to generate
    """
    if client is None:
        client = get_gemini_client()
    
    # Build the prompt
    understanding_json = understanding.model_dump_json(indent=2)
    file_list_str = "\n".join(f"- {f}" for f in file_list[:50])  # Limit files
    
    prompt = SCRIPT_PLAN_PROMPT.format(
        understanding_json=understanding_json,
        file_list=file_list_str,
    )
    
    plan = await client.generate_structured_async(
        prompt=prompt,
        response_schema=ScriptPlan,
        system_instruction=SCRIPT_GENERATION_SYSTEM,
        temperature=0.3,
    )
    
    return plan


async def generate_script_code(
    script: GeneratedScript,
    understanding: ExperimentUnderstanding,
    output_dir: str,
    client: GeminiClient | None = None,
) -> str:
    """Generate the actual code for a script.
    
    Args:
        script: The script specification
        understanding: Experiment context
        output_dir: Where outputs should be saved
        client: Optional Gemini client
    
    Returns:
        The generated script code
    """
    if client is None:
        client = get_gemini_client()
    
    prompt = SCRIPT_CODE_PROMPT.format(
        script_name=script.name,
        category=script.category.value,
        script_type=script.script_type.value,
        description=script.description,
        understanding_summary=understanding.summary,
        input_files="\n".join(f"- {f}" for f in script.input_files),
        output_dir=output_dir,
        output_files="\n".join(f"- {f}" for f in script.output_files),
        dependencies=", ".join(script.dependencies),
    )
    
    # For code generation, we want raw text output
    response = await client.generate_async(
        prompt=prompt,
        system_instruction=SCRIPT_GENERATION_SYSTEM,
        temperature=0.2,  # Lower temp for code
    )
    
    # Extract code from markdown code blocks if present
    code = response.strip()
    if code.startswith("```"):
        lines = code.split("\n")
        # Remove first and last lines (``` markers)
        code = "\n".join(lines[1:-1] if lines[-1].strip() == "```" else lines[1:])
    
    return code


def get_script_extension(script_type: ScriptType) -> str:
    """Get the file extension for a script type."""
    return {
        ScriptType.PYTHON: ".py",
        ScriptType.BASH: ".sh",
        ScriptType.R: ".R",
    }[script_type]
